# 🌐 Multi-Broker Deployment System

**Deploy your strategies to IBKR, Bybit, and MT5 from a single unified interface**

---

## 🎯 Overview

This guide shows how to deploy strategies generated by our Strategy Factory to three different broker types:

- **IBKR** (Interactive Brokers) - Stocks, options, futures
- **Bybit** - Cryptocurrency spot and derivatives
- **MT5** (MetaTrader 5) - Forex, CFDs

---

## 📚 Required Libraries

```bash
# IBKR - Use ib_async (modernized fork of ib_insync)
pip install ib_async

# Bybit - Use CCXT (unified crypto API)
pip install ccxt

# MT5 - Official MetaTrader5 package (Windows only)
pip install MetaTrader5

# Common utilities
pip install pandas numpy
```

### Important Notes:
- **ib_async** is the recommended modern fork (ib_insync is no longer maintained)
- **MT5 Python API only works on Windows**
- IBKR requires TWS or IB Gateway running (port 7496)
- MT5 requires MetaTrader 5 terminal installed

---

## 🏗️ Architecture Design

### Unified Broker Interface Pattern

```
┌─────────────────────────────────────────┐
│      Strategy Factory Output            │
│  (Strategy signals: BUY/SELL/CLOSE)     │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│     Unified Broker Interface            │
│  (Abstract base class)                  │
└──┬───────────┬───────────┬──────────────┘
   │           │           │
   │           │           │
┌──▼────┐  ┌──▼─────┐  ┌──▼────┐
│ IBKR  │  │ Bybit  │  │  MT5  │
│Adapter│  │Adapter │  │Adapter│
└───────┘  └────────┘  └───────┘
```

---

## 💻 Implementation

### 1. Base Broker Interface

Create `deployment/broker_interface.py`:

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional, Dict, Any
import pandas as pd

class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"

class OrderType(Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"

@dataclass
class Order:
    """Unified order structure"""
    symbol: str
    side: OrderSide
    quantity: float
    order_type: OrderType = OrderType.MARKET
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None

@dataclass
class Position:
    """Unified position structure"""
    symbol: str
    quantity: float
    avg_price: float
    unrealized_pnl: float
    realized_pnl: float

@dataclass
class BarData:
    """Unified OHLCV bar"""
    timestamp: pd.Timestamp
    open: float
    high: float
    low: float
    close: float
    volume: float

class BaseBroker(ABC):
    """Abstract base class for all broker adapters"""

    @abstractmethod
    def connect(self) -> bool:
        """Connect to broker"""
        pass

    @abstractmethod
    def disconnect(self) -> None:
        """Disconnect from broker"""
        pass

    @abstractmethod
    def get_balance(self) -> float:
        """Get account balance"""
        pass

    @abstractmethod
    def get_positions(self) -> Dict[str, Position]:
        """Get all open positions"""
        pass

    @abstractmethod
    def place_order(self, order: Order) -> str:
        """Place order, return order ID"""
        pass

    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """Cancel order"""
        pass

    @abstractmethod
    def get_historical_data(self, symbol: str, timeframe: str,
                           bars: int = 500) -> pd.DataFrame:
        """Get historical OHLCV data"""
        pass

    @abstractmethod
    def get_current_price(self, symbol: str) -> float:
        """Get current market price"""
        pass
```

---

### 2. IBKR Adapter

Create `deployment/ibkr_adapter.py`:

```python
from ib_async import IB, Stock, MarketOrder, LimitOrder, StopOrder
from ib_async import util
from broker_interface import *
import asyncio

class IBKRAdapter(BaseBroker):
    """Interactive Brokers adapter using ib_async"""

    def __init__(self, host='127.0.0.1', port=7496, client_id=1):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.ib = IB()

    def connect(self) -> bool:
        """Connect to TWS/IB Gateway"""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            print(f"✅ Connected to IBKR (clientId={self.client_id})")
            return True
        except Exception as e:
            print(f"❌ IBKR connection failed: {e}")
            return False

    def disconnect(self) -> None:
        """Disconnect from IBKR"""
        self.ib.disconnect()
        print("🔌 Disconnected from IBKR")

    def get_balance(self) -> float:
        """Get account balance"""
        summary = self.ib.accountSummary()
        for item in summary:
            if item.tag == 'NetLiquidation':
                return float(item.value)
        return 0.0

    def get_positions(self) -> Dict[str, Position]:
        """Get all open positions"""
        positions = {}
        for pos in self.ib.positions():
            symbol = pos.contract.symbol
            positions[symbol] = Position(
                symbol=symbol,
                quantity=pos.position,
                avg_price=pos.avgCost,
                unrealized_pnl=pos.unrealizedPNL,
                realized_pnl=0.0  # Not directly available
            )
        return positions

    def place_order(self, order: Order) -> str:
        """Place order"""
        # Create contract
        contract = Stock(order.symbol, 'SMART', 'USD')

        # Create order based on type
        if order.order_type == OrderType.MARKET:
            ib_order = MarketOrder(
                order.side.value,
                order.quantity
            )
        elif order.order_type == OrderType.LIMIT:
            ib_order = LimitOrder(
                order.side.value,
                order.quantity,
                order.limit_price
            )
        elif order.order_type == OrderType.STOP:
            ib_order = StopOrder(
                order.side.value,
                order.quantity,
                order.stop_price
            )
        else:
            raise ValueError(f"Unsupported order type: {order.order_type}")

        # Place order
        trade = self.ib.placeOrder(contract, ib_order)
        print(f"📤 IBKR order placed: {order.symbol} {order.side.value} {order.quantity}")

        return str(trade.order.orderId)

    def cancel_order(self, order_id: str) -> bool:
        """Cancel order"""
        for trade in self.ib.openTrades():
            if str(trade.order.orderId) == order_id:
                self.ib.cancelOrder(trade.order)
                return True
        return False

    def get_historical_data(self, symbol: str, timeframe: str,
                           bars: int = 500) -> pd.DataFrame:
        """Get historical data"""
        contract = Stock(symbol, 'SMART', 'USD')

        # Map timeframe (e.g., '5m' -> '5 mins')
        bar_size = self._map_timeframe(timeframe)
        duration = f"{bars * self._timeframe_to_minutes(timeframe)} S"

        # Request data
        bars_data = self.ib.reqHistoricalData(
            contract,
            endDateTime='',
            durationStr=duration,
            barSizeSetting=bar_size,
            whatToShow='TRADES',
            useRTH=False
        )

        # Convert to DataFrame
        df = util.df(bars_data)
        df = df.rename(columns={
            'date': 'timestamp',
            'open': 'open',
            'high': 'high',
            'low': 'low',
            'close': 'close',
            'volume': 'volume'
        })

        return df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]

    def get_current_price(self, symbol: str) -> float:
        """Get current price"""
        contract = Stock(symbol, 'SMART', 'USD')
        ticker = self.ib.reqMktData(contract)
        self.ib.sleep(1)  # Wait for data

        if ticker.last:
            return ticker.last
        elif ticker.close:
            return ticker.close
        else:
            return 0.0

    def _map_timeframe(self, tf: str) -> str:
        """Map timeframe to IBKR format"""
        mapping = {
            '1m': '1 min',
            '5m': '5 mins',
            '15m': '15 mins',
            '1h': '1 hour',
            '1d': '1 day'
        }
        return mapping.get(tf, '5 mins')

    def _timeframe_to_minutes(self, tf: str) -> int:
        """Convert timeframe to minutes"""
        mapping = {'1m': 1, '5m': 5, '15m': 15, '1h': 60, '1d': 1440}
        return mapping.get(tf, 5)
```

---

### 3. Bybit Adapter

Create `deployment/bybit_adapter.py`:

```python
import ccxt
from broker_interface import *

class BybitAdapter(BaseBroker):
    """Bybit adapter using CCXT"""

    def __init__(self, api_key: str, api_secret: str, testnet: bool = False):
        self.api_key = api_key
        self.api_secret = api_secret
        self.testnet = testnet
        self.exchange = None

    def connect(self) -> bool:
        """Connect to Bybit"""
        try:
            self.exchange = ccxt.bybit({
                'apiKey': self.api_key,
                'secret': self.api_secret,
                'enableRateLimit': True,
                'options': {
                    'defaultType': 'linear',  # USDT perpetuals
                }
            })

            if self.testnet:
                self.exchange.set_sandbox_mode(True)

            # Test connection
            balance = self.exchange.fetch_balance()
            print(f"✅ Connected to Bybit {'(Testnet)' if self.testnet else ''}")
            return True

        except Exception as e:
            print(f"❌ Bybit connection failed: {e}")
            return False

    def disconnect(self) -> None:
        """Disconnect from Bybit"""
        self.exchange = None
        print("🔌 Disconnected from Bybit")

    def get_balance(self) -> float:
        """Get account balance"""
        balance = self.exchange.fetch_balance()
        return balance['USDT']['free'] if 'USDT' in balance else 0.0

    def get_positions(self) -> Dict[str, Position]:
        """Get all open positions"""
        positions = {}
        raw_positions = self.exchange.fetch_positions()

        for pos in raw_positions:
            if pos['contracts'] > 0:  # Only open positions
                symbol = pos['symbol']
                positions[symbol] = Position(
                    symbol=symbol,
                    quantity=pos['contracts'],
                    avg_price=pos['entryPrice'],
                    unrealized_pnl=pos['unrealizedPnl'],
                    realized_pnl=pos['realizedPnl']
                )

        return positions

    def place_order(self, order: Order) -> str:
        """Place order"""
        params = {}

        # Create order
        ccxt_order = self.exchange.create_order(
            symbol=order.symbol,
            type=order.order_type.value.lower(),
            side=order.side.value.lower(),
            amount=order.quantity,
            price=order.limit_price if order.order_type == OrderType.LIMIT else None,
            params=params
        )

        print(f"📤 Bybit order placed: {order.symbol} {order.side.value} {order.quantity}")
        return ccxt_order['id']

    def cancel_order(self, order_id: str) -> bool:
        """Cancel order"""
        try:
            self.exchange.cancel_order(order_id)
            return True
        except Exception as e:
            print(f"❌ Cancel failed: {e}")
            return False

    def get_historical_data(self, symbol: str, timeframe: str,
                           bars: int = 500) -> pd.DataFrame:
        """Get historical data"""
        # Fetch OHLCV
        ohlcv = self.exchange.fetch_ohlcv(
            symbol=symbol,
            timeframe=timeframe,
            limit=bars
        )

        # Convert to DataFrame
        df = pd.DataFrame(
            ohlcv,
            columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']
        )
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

        return df

    def get_current_price(self, symbol: str) -> float:
        """Get current price"""
        ticker = self.exchange.fetch_ticker(symbol)
        return ticker['last']
```

---

### 4. MT5 Adapter

Create `deployment/mt5_adapter.py`:

```python
import MetaTrader5 as mt5
from broker_interface import *

class MT5Adapter(BaseBroker):
    """MetaTrader 5 adapter (Windows only)"""

    def __init__(self, login: int, password: str, server: str):
        self.login = login
        self.password = password
        self.server = server

    def connect(self) -> bool:
        """Connect to MT5"""
        if not mt5.initialize():
            print(f"❌ MT5 initialize() failed: {mt5.last_error()}")
            return False

        # Login
        authorized = mt5.login(self.login, password=self.password, server=self.server)

        if not authorized:
            print(f"❌ MT5 login failed: {mt5.last_error()}")
            mt5.shutdown()
            return False

        print(f"✅ Connected to MT5 (Account: {self.login})")
        return True

    def disconnect(self) -> None:
        """Disconnect from MT5"""
        mt5.shutdown()
        print("🔌 Disconnected from MT5")

    def get_balance(self) -> float:
        """Get account balance"""
        account_info = mt5.account_info()
        return account_info.balance if account_info else 0.0

    def get_positions(self) -> Dict[str, Position]:
        """Get all open positions"""
        positions = {}
        raw_positions = mt5.positions_get()

        if raw_positions:
            for pos in raw_positions:
                symbol = pos.symbol
                positions[symbol] = Position(
                    symbol=symbol,
                    quantity=pos.volume,
                    avg_price=pos.price_open,
                    unrealized_pnl=pos.profit,
                    realized_pnl=0.0  # Not directly available
                )

        return positions

    def place_order(self, order: Order) -> str:
        """Place order"""
        # Get symbol info
        symbol_info = mt5.symbol_info(order.symbol)
        if symbol_info is None:
            print(f"❌ {order.symbol} not found")
            return ""

        # Prepare order
        point = symbol_info.point
        price = mt5.symbol_info_tick(order.symbol).ask if order.side == OrderSide.BUY else mt5.symbol_info_tick(order.symbol).bid

        # Map order type
        if order.order_type == OrderType.MARKET:
            order_type = mt5.ORDER_TYPE_BUY if order.side == OrderSide.BUY else mt5.ORDER_TYPE_SELL
        elif order.order_type == OrderType.LIMIT:
            order_type = mt5.ORDER_TYPE_BUY_LIMIT if order.side == OrderSide.BUY else mt5.ORDER_TYPE_SELL_LIMIT
            price = order.limit_price
        elif order.order_type == OrderType.STOP:
            order_type = mt5.ORDER_TYPE_BUY_STOP if order.side == OrderSide.BUY else mt5.ORDER_TYPE_SELL_STOP
            price = order.stop_price
        else:
            raise ValueError(f"Unsupported order type: {order.order_type}")

        # Create request
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": order.symbol,
            "volume": order.quantity,
            "type": order_type,
            "price": price,
            "deviation": 20,
            "magic": 234000,
            "comment": "Strategy Factory",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }

        # Send order
        result = mt5.order_send(request)

        if result.retcode != mt5.TRADE_RETCODE_DONE:
            print(f"❌ MT5 order failed: {result.comment}")
            return ""

        print(f"📤 MT5 order placed: {order.symbol} {order.side.value} {order.quantity}")
        return str(result.order)

    def cancel_order(self, order_id: str) -> bool:
        """Cancel order"""
        request = {
            "action": mt5.TRADE_ACTION_REMOVE,
            "order": int(order_id)
        }
        result = mt5.order_send(request)
        return result.retcode == mt5.TRADE_RETCODE_DONE

    def get_historical_data(self, symbol: str, timeframe: str,
                           bars: int = 500) -> pd.DataFrame:
        """Get historical data"""
        # Map timeframe
        tf_map = {
            '1m': mt5.TIMEFRAME_M1,
            '5m': mt5.TIMEFRAME_M5,
            '15m': mt5.TIMEFRAME_M15,
            '1h': mt5.TIMEFRAME_H1,
            '1d': mt5.TIMEFRAME_D1
        }
        mt5_timeframe = tf_map.get(timeframe, mt5.TIMEFRAME_M5)

        # Fetch data
        rates = mt5.copy_rates_from_pos(symbol, mt5_timeframe, 0, bars)

        if rates is None:
            print(f"❌ Failed to get data for {symbol}")
            return pd.DataFrame()

        # Convert to DataFrame
        df = pd.DataFrame(rates)
        df['timestamp'] = pd.to_datetime(df['time'], unit='s')
        df = df.rename(columns={'tick_volume': 'volume'})

        return df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]

    def get_current_price(self, symbol: str) -> float:
        """Get current price"""
        tick = mt5.symbol_info_tick(symbol)
        return tick.ask if tick else 0.0
```

---

### 5. Unified Strategy Deployer

Create `deployment/strategy_deployer.py`:

```python
from broker_interface import *
from ibkr_adapter import IBKRAdapter
from bybit_adapter import BybitAdapter
from mt5_adapter import MT5Adapter
from typing import Dict, Any
import json

class StrategyDeployer:
    """Deploy strategies to multiple brokers from unified interface"""

    def __init__(self, config_path: str = 'deployment/config.json'):
        self.config = self._load_config(config_path)
        self.brokers: Dict[str, BaseBroker] = {}

    def _load_config(self, path: str) -> Dict[str, Any]:
        """Load broker configuration"""
        with open(path, 'r') as f:
            return json.load(f)

    def connect_all(self) -> None:
        """Connect to all configured brokers"""
        # IBKR
        if 'ibkr' in self.config:
            ibkr = IBKRAdapter(
                host=self.config['ibkr']['host'],
                port=self.config['ibkr']['port'],
                client_id=self.config['ibkr']['client_id']
            )
            if ibkr.connect():
                self.brokers['ibkr'] = ibkr

        # Bybit
        if 'bybit' in self.config:
            bybit = BybitAdapter(
                api_key=self.config['bybit']['api_key'],
                api_secret=self.config['bybit']['api_secret'],
                testnet=self.config['bybit'].get('testnet', False)
            )
            if bybit.connect():
                self.brokers['bybit'] = bybit

        # MT5
        if 'mt5' in self.config:
            mt5 = MT5Adapter(
                login=self.config['mt5']['login'],
                password=self.config['mt5']['password'],
                server=self.config['mt5']['server']
            )
            if mt5.connect():
                self.brokers['mt5'] = mt5

        print(f"\n✅ Connected to {len(self.brokers)} broker(s)")

    def disconnect_all(self) -> None:
        """Disconnect from all brokers"""
        for name, broker in self.brokers.items():
            broker.disconnect()
        self.brokers = {}

    def deploy_strategy(self, strategy_name: str, broker_name: str,
                       symbol: str, timeframe: str = '5m'):
        """Deploy strategy to specific broker"""
        if broker_name not in self.brokers:
            print(f"❌ Broker '{broker_name}' not connected")
            return

        broker = self.brokers[broker_name]

        # Load strategy
        strategy_module = __import__(f'strategies.{strategy_name}')
        strategy_class = getattr(strategy_module, strategy_name.title())
        strategy = strategy_class()

        print(f"\n🚀 Deploying {strategy_name} to {broker_name}")
        print(f"Symbol: {symbol} | Timeframe: {timeframe}")

        # Get historical data
        df = broker.get_historical_data(symbol, timeframe, bars=500)

        # Generate signals
        signals = strategy.generate_signals(df)

        # Execute latest signal
        if len(signals) > 0:
            latest = signals.iloc[-1]

            if latest['signal'] == 'BUY':
                order = Order(
                    symbol=symbol,
                    side=OrderSide.BUY,
                    quantity=self._calculate_position_size(broker, symbol),
                    order_type=OrderType.MARKET
                )
                broker.place_order(order)

            elif latest['signal'] == 'SELL':
                order = Order(
                    symbol=symbol,
                    side=OrderSide.SELL,
                    quantity=self._calculate_position_size(broker, symbol),
                    order_type=OrderType.MARKET
                )
                broker.place_order(order)

    def get_all_positions(self) -> Dict[str, Dict[str, Position]]:
        """Get positions from all brokers"""
        all_positions = {}
        for name, broker in self.brokers.items():
            all_positions[name] = broker.get_positions()
        return all_positions

    def get_all_balances(self) -> Dict[str, float]:
        """Get balances from all brokers"""
        balances = {}
        for name, broker in self.brokers.items():
            balances[name] = broker.get_balance()
        return balances

    def _calculate_position_size(self, broker: BaseBroker, symbol: str) -> float:
        """Calculate position size based on account balance and risk"""
        balance = broker.get_balance()
        risk_per_trade = 0.01  # 1% risk

        # Simple fixed percentage
        position_value = balance * risk_per_trade
        current_price = broker.get_current_price(symbol)

        quantity = position_value / current_price if current_price > 0 else 0
        return round(quantity, 2)
```

---

## 📋 Configuration File

Create `deployment/config.json`:

```json
{
  "ibkr": {
    "host": "127.0.0.1",
    "port": 7496,
    "client_id": 1
  },
  "bybit": {
    "api_key": "YOUR_BYBIT_API_KEY",
    "api_secret": "YOUR_BYBIT_SECRET",
    "testnet": true
  },
  "mt5": {
    "login": 12345678,
    "password": "YOUR_MT5_PASSWORD",
    "server": "MetaQuotes-Demo"
  }
}
```

---

## 🚀 Usage Example

Create `deployment/example_deploy.py`:

```python
from strategy_deployer import StrategyDeployer

# Initialize deployer
deployer = StrategyDeployer('deployment/config.json')

# Connect to all brokers
deployer.connect_all()

# Check balances
balances = deployer.get_all_balances()
print("\n💰 Account Balances:")
for broker, balance in balances.items():
    print(f"  {broker}: ${balance:,.2f}")

# Check positions
positions = deployer.get_all_positions()
print("\n📊 Open Positions:")
for broker, pos_dict in positions.items():
    print(f"\n{broker}:")
    for symbol, pos in pos_dict.items():
        print(f"  {symbol}: {pos.quantity} @ ${pos.avg_price:.2f} (P&L: ${pos.unrealized_pnl:.2f})")

# Deploy strategies to different brokers
deployer.deploy_strategy(
    strategy_name='sma_crossover',
    broker_name='ibkr',
    symbol='AAPL',
    timeframe='5m'
)

deployer.deploy_strategy(
    strategy_name='rsi_mean_reversion',
    broker_name='bybit',
    symbol='BTC/USDT',
    timeframe='5m'
)

deployer.deploy_strategy(
    strategy_name='breakout',
    broker_name='mt5',
    symbol='EURUSD',
    timeframe='5m'
)

# Disconnect
deployer.disconnect_all()
```

---

## 📁 Project Structure

```
04_BYBIT_multi/
├── deployment/
│   ├── __init__.py
│   ├── broker_interface.py       # Base classes
│   ├── ibkr_adapter.py           # IBKR implementation
│   ├── bybit_adapter.py          # Bybit implementation
│   ├── mt5_adapter.py            # MT5 implementation
│   ├── strategy_deployer.py      # Unified deployer
│   ├── config.json               # Broker credentials
│   └── example_deploy.py         # Usage example
│
├── strategy_factory/
│   ├── generator.py              # Generate strategies
│   ├── optimizer.py              # Optimize parameters
│   └── analyzer.py               # Performance analysis
│
└── strategies/
    ├── sma_crossover.py          # Strategy 1
    ├── rsi_mean_reversion.py    # Strategy 2
    └── breakout.py               # Strategy 3
```

---

## ⚠️ Important Considerations

### Platform Limitations

| Feature | IBKR | Bybit | MT5 |
|---------|------|-------|-----|
| **OS Support** | Windows, Mac, Linux | All | **Windows only** |
| **Asset Classes** | Stocks, options, futures, forex | Crypto | Forex, CFDs, stocks |
| **Python API** | ib_async | CCXT | MetaTrader5 |
| **Gateway Required** | TWS/IB Gateway | No | MT5 Terminal |

### Risk Management

1. **Test on demo accounts first**
2. **Start with small position sizes**
3. **Monitor all brokers simultaneously**
4. **Set up stop-losses on all positions**
5. **Keep detailed logs**

### Connection Requirements

- **IBKR**: Requires TWS or IB Gateway running (free)
- **Bybit**: Direct API connection (no additional software)
- **MT5**: Requires MetaTrader 5 terminal installed

---

## 🎯 Next Steps

1. **Install dependencies**:
   ```bash
   pip install ib_async ccxt MetaTrader5
   ```

2. **Set up demo accounts**:
   - IBKR Paper Trading
   - Bybit Testnet
   - MT5 Demo Account

3. **Configure credentials** in `config.json`

4. **Test connections**:
   ```python
   deployer = StrategyDeployer()
   deployer.connect_all()
   ```

5. **Deploy your first strategy**!

---

## 📚 Resources

### IBKR
- ib_async GitHub: https://github.com/ib-api-reloaded/ib_async
- IBKR API Docs: https://www.interactivebrokers.com/campus/ibkr-api-page/twsapi-doc/

### Bybit
- CCXT Documentation: https://docs.ccxt.com/
- Bybit API Docs: https://bybit-exchange.github.io/docs/

### MT5
- Official Python Integration: https://www.mql5.com/en/docs/python_metatrader5
- MetaTrader5 PyPI: https://pypi.org/project/MetaTrader5/

---

## ⚠️ Disclaimer

Trading involves substantial risk. Test thoroughly on demo accounts before live trading. Past performance doesn't guarantee future results. Use at your own risk.

---

**Ready to deploy? Start with [example_deploy.py](deployment/example_deploy.py)!**
